import random
from typing import Optional

import numpy as np

from cnrg.LightMultiGraph import LightMultiGraph
from cnrg.VRG import VRG
from cnrg.Rule import PartRule
from cnrg.globals import find_boundary_edges


def generate_graph(target_n: int, grammar: VRG, merge_iso_rules: bool,
                   tolerance: float = 0.05) -> tuple[LightMultiGraph, list[int]]:
    """
        Applies the rules in a given grammar to generate a graph `G` from scratch.

        Required arguments:
            targen_n: number of nodes that should be in the generated graph (i.e., the expected order of `G`)
            grammar: the Vertex-Replacement Graph Grammar whose rules will be used for generation
            merge_iso_rules: whether or not to consider isomorphic rules identical

        Optional arguments:
            tolerance: the percentage allowable deviation from `target_n` for the order of `G`
                       set to `0.05` by default

        Returns:
            A tuple `(G, gen_seq)`, where:
                `G` is the graph generated by the grammar
                `gen_seq` is a list of the indices (in the decomposition) of the rules in the order they were applied to generate `G`.
    """
    grammar.compute_rules(merge=merge_iso_rules)

    lower_bound = int(target_n * (1 - tolerance))
    upper_bound = int(target_n * (1 + tolerance))
    max_trials = 1_000
    trial = 0
    while True:
        if trial > max_trials:
            raise TimeoutError(f'Generation failed in {max_trials} steps')

        g, rule_ordering = _generate_graph(rules=grammar.rules, upper_bound=upper_bound)
        if g is None:  # early termination
            continue
        if lower_bound <= g.order() <= upper_bound:  # if the number of nodes falls in bounds,
            break

        trial += 1

    if trial > 1:
        print(f'Graph generated in {trial} tries.')
    print(f'Generated graph: n = {g.order()}, m = {g.size()}')

    return g, rule_ordering


def _generate_graph(rules: dict[int, list[PartRule]], upper_bound: int) -> tuple[Optional[LightMultiGraph], Optional[list[int]]]:
    """
        Helper function for `generate_graph()`

        Required arguments:
            rules: a dictionary mapping {LHS => rule} for the different rules in the grammar
            upper_bound: the maximum allowable number of nodes in the generated graph

        Returns:
            A tuple `(G, gen_seq)`, where:
                `G` is the graph generated by the grammar
                `gen_seq` is a list of the indices (in the decomposition) of the rules in the order they were applied to generate `G`.
    """
    node_counter = 1
    rng = np.random.default_rng()

    # find the starting rule
    S = min(rules)
    new_g = LightMultiGraph()
    new_g.add_node(S, label=S)
    # new_g.add_node(0, label=0)

    # non_terminals = {0}
    nonterminals = [S]  # nonterminals = [v for v, d in new_g.nodes(data=True) if 'label' in d]
    rule_ordering = []  # list of rule.idn in the order they were fired

    while len(nonterminals) > 0:
        if new_g.order() > upper_bound:  # graph got too large; abort
            return None, None

        # choose a nonterminal symbol at random
        # nts, = random.sample(nonterminals, 1)  # nts, = random.sample([v for v, d in new_g.nodes(data=True) if 'label' in d], 1)
        nts = rng.choice(nonterminals)
        lhs = new_g.nodes[nts]['label']
        rule_candidates = rules[lhs]

        # select a new rule to apply at the chosen nonterminal symbol
        freqs = np.asarray([candidate.frequency for candidate in rule_candidates])
        weights = freqs / np.sum(freqs)  # normalize into probabilities
        rule = rng.choice(rule_candidates, p=weights)  # pick based on probability
        rule = rule.copy()  # copy the rule, since we don't want to keep any metadata modifications we may make
        rhs = rule.graph

        rule_ordering += [rule.idn]
        broken_edges = find_boundary_edges(new_g, {nts})
        assert len(broken_edges) == lhs if lhs >= 0 else True

        # get ready to replace the chosen nonterminal with the right-hand side
        new_g.remove_node(nts)
        nonterminals.remove(nts)

        # add the nodes from the right-hand side to the generated graph
        node_map = {}
        for n, d in rhs.nodes(data=True):  # all the nodes are internal
            new_node = node_counter
            node_map[n] = new_node
            attr = {'b_deg': d['b_deg']}

            # if it's a new nonterminal, add it to the set of nonterminal symbols
            if 'label' in d:
                nonterminals.append(new_node)
                attr['label'] = d['label']

            # sample a color for this node if there are colors available
            if 'colors' in d.keys():
                attr['color'] = rng.choice(d['colors'])

            new_g.add_node(new_node, **attr)
            node_counter += 1

        # randomly assign broken edges to boundary edges
        # random.shuffle(broken_edges)

        # randomly joining the new boundary edges from the RHS to the rest of the graph - uniformly at random
        while len(broken_edges) > 0:
            # pick a broken edge to rewire
            eidx = rng.choice(len(broken_edges))
            u, v, *d = broken_edges[eidx]
            broken_edges.pop(eidx)

            # pick an admissable node on the rule's graph to wire that edge to
            n = rng.choice([v for v, d in rhs.nodes(data=True) if d['b_deg'] > 0])
            rhs.nodes[n]['b_deg'] -= 1

            # one of the end-points of e should be the nonterminal we are replacing
            # we are assuming there are no self-edges on nonterminal symbols
            if nts == u and nts != v:
                u = node_map[n]
            elif nts != u and nts == v:
                v = node_map[n]
            else:
                raise AssertionError(f'investigate: {nts}, {u}, {v}, {d}')

            new_g.add_edge(u, v, **dict(d))

        # adding the right-hand side to the generated
        for u, v, d in rhs.edges(data=True):
            edge_multiplicity = d['weight']
            if 'colors' in d:
                edge_color = rng.choice(d['colors'])
                new_g.add_edge(node_map[u], node_map[v], weight=edge_multiplicity, edge_color=edge_color)
            else:
                new_g.add_edge(node_map[u], node_map[v], weight=edge_multiplicity)

    return new_g, rule_ordering
